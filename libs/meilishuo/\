'use strict';

var api = require('./api');
var ENV = require('../../config/server')['ENV'];
var dbcfg = require('../../config/db')[ENV];
var db = require('../../common/database/mysql');

/**
 * 错误匹配
 * @param resp {String} 接口返回数据
 * @return {String} 错误提示
 * @constructor
 */
var _parse_error = function(resp) {
    var error = '', o;

    try { o = JSON.parse(resp); }
    catch (e) { return '获取订单数据出错'; }
    
    if (!o) {
        error = '平台接口数据错误';
    }
    else {
        var s = o.status;
        
        var error_desc = {
            3: '订单已发货',
            5: '订单已完成',
            7: '订单已关闭',
            refund_s: {
                1: '1', 2: '2', 3: '3', 5: '5', 7: '7'    
            }
        };

        if(error_desc[s]) {
            error = error_desc[s];    
        }
        else if (o.products) {
            o.products.forEach(function(el) {
                var rfs = el.refund_status;

                if (error_desc.refund_s[rfs]) {
                    error = error_desc.refund_s[rfs];    
                }
            });
        }
        else if ('2' != s) {
            error = '订单状态错误:' + s;
        }
    }

    return error;
};

/**
 * 检查订单状态是否能发货
 * @param access_token {String} 平台授权码
 * @param tid {String} 订单号
 * @param cb {Function} 回调函数
 * @constructor
 */
exports.check_trade_status = function(app_type, access_token, tid, cb) {
    var p = {
        app_type: app_type,
        access_token: access_token,
		method: 'api/erp/v2/orders/' + (tid.tid || tid) + '.json'
    };

    api.post(p, function(err, resp) {
        var _err = err || _parse_error(resp);
        _err && tid.tid && (_err = tid.tid + _err); 
        cb(null, { msg: _err, tid: tid.ptid || tid });
    });
};

var fn = {
    get_trades (resp) { return resp.order_list_get_response.info; },
    get_tid (trade) { return trade.order.order_id; },
    get_status (trade) { return trade.order.status_text; }
};

var handle_trades = function(resp) {
    var v = {};
    v.edit_trades = {};
    v.add_trades = {};
    v.o_trades = JSON.parse(resp);
    v.o_trades = fn.get_trades(v.o_trades);
    v.tids = [];
    v.trade_infos = {};

    v.o_trades.forEach(function(el) {
         var tid = fn.get_tid(el);

         v.tids.push(tid);
         v.trade_infos[tid] = fn.get_status(el);
    });

    Promise.resolve(1).then( () => {
        return get_sys_trade(v).then(r => {
            r.forEach(function(el) {
                var tid = el.tid;
                var s_status = v.trade_infos[tid];

                if (!s_status) {
                    v.add_trades[tid] = 1;
                }
                else if (el.status != v.trade_info[tid]) {
                    v.edit_trades[tid] = 1;
                }
            });
        });
    }).then(() => {
        return get_platfrom_trades(v);              
    }).catch(err => {
        console.log(err.stack); 
    });
};

var get_platfrom_trades = function(v) {
    var pall = [];

    v.tids.forEach(function(el) {
        let p = {
            app_type: app_type,
            access_token: params.access_token,
            method: 'meilishuo.order.detail.get',
            order_id: el.tid 
        };

        pall.push( new Promise((resolve, reject) => {
            api.post(p, (err, resp) => {
                if (err || resp.error_response) {
                    reject('get trade error');    
                }
                else {
                    v.trade_info[el.tid] = resp;
                    resolve(resp);
                }
            }); 
        }));
    });

    return Promise.all(pall);
};

var get_sys_trade = function(v) {
    db.init(dbcfg);
    var sql = 'select tid, status from jdp_meilishuo_trade where tid in(\'' + v.tids.join('\',\'');
    console.log(sql);
    return db.doQuery(sql);
};

var download_trade = function(app_type, params) {
     var p = {
        app_type: app_type,
        access_token: params.access_token,
		method: 'meilishuo.order.list.get',
        page: params.page,
        page_size: params.page_size,
        uptime_start: params.last_trans_time,
        uptime_end: params.trans_end_time
    };

    return new Promise((resolve, reject) => {
        api.post(p, (err, resp) => {
            if (err || resp.indexOf('error_response') != -1) {
                reject('get trade error');    
            }
            else resolve(resp);
        }); 
    }).then(r => {
        return handle_trades(r);
    }).catch(err => {
        console.log(err.stack || err);    
    });
};

download_trade(4, {
    access_token: '8bebb2b14b783641b75a8ac18ca3b203',
    page: 0,
    page_size: 2,
    last_trans_time: '2015-05-01 00:00:01',
    trans_end_time: '2015-05-02 00:00:01'
});













